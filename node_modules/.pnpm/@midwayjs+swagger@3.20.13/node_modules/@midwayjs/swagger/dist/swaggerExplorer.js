"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwaggerExplorer = void 0;
const core_1 = require("@midwayjs/core");
const constants_1 = require("./constants");
const documentBuilder_1 = require("./documentBuilder");
const _1 = require(".");
const enum_utils_1 = require("./common/enum.utils");
let SwaggerExplorer = class SwaggerExplorer {
    constructor() {
        this.swaggerConfig = {};
        this.documentBuilder = new documentBuilder_1.DocumentBuilder();
        this.operationIdFactory = (controllerKey, webRouter) => `${controllerKey.toLowerCase()}_${webRouter.method.toLocaleLowerCase()}`;
    }
    async init() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _2, _3, _4, _5, _6, _7;
        this.documentBuilder.setTitle(this.swaggerConfig.title);
        this.documentBuilder.setVersion(this.swaggerConfig.version);
        this.documentBuilder.setDescription(this.swaggerConfig.description);
        if (((_a = this.swaggerConfig) === null || _a === void 0 ? void 0 : _a.contact) &&
            typeof ((_b = this.swaggerConfig) === null || _b === void 0 ? void 0 : _b.contact) === 'object') {
            this.documentBuilder.setContact((_d = (_c = this.swaggerConfig) === null || _c === void 0 ? void 0 : _c.contact) === null || _d === void 0 ? void 0 : _d.name, (_f = (_e = this.swaggerConfig) === null || _e === void 0 ? void 0 : _e.contact) === null || _f === void 0 ? void 0 : _f.url, (_h = (_g = this.swaggerConfig) === null || _g === void 0 ? void 0 : _g.contact) === null || _h === void 0 ? void 0 : _h.email);
        }
        if (((_j = this.swaggerConfig) === null || _j === void 0 ? void 0 : _j.license) &&
            typeof ((_k = this.swaggerConfig) === null || _k === void 0 ? void 0 : _k.license) === 'object') {
            this.documentBuilder.setLicense((_m = (_l = this.swaggerConfig) === null || _l === void 0 ? void 0 : _l.license) === null || _m === void 0 ? void 0 : _m.name, (_p = (_o = this.swaggerConfig) === null || _o === void 0 ? void 0 : _o.license) === null || _p === void 0 ? void 0 : _p.url);
        }
        if (this.swaggerConfig.termsOfService) {
            this.documentBuilder.setTermsOfService(this.swaggerConfig.termsOfService);
        }
        if (((_q = this.swaggerConfig) === null || _q === void 0 ? void 0 : _q.externalDocs) &&
            typeof ((_r = this.swaggerConfig) === null || _r === void 0 ? void 0 : _r.externalDocs) === 'object') {
            this.documentBuilder.setExternalDoc((_t = (_s = this.swaggerConfig) === null || _s === void 0 ? void 0 : _s.externalDocs) === null || _t === void 0 ? void 0 : _t.description, (_v = (_u = this.swaggerConfig) === null || _u === void 0 ? void 0 : _u.externalDocs) === null || _v === void 0 ? void 0 : _v.url);
        }
        if (((_w = this.swaggerConfig) === null || _w === void 0 ? void 0 : _w.servers) &&
            Array.isArray((_x = this.swaggerConfig) === null || _x === void 0 ? void 0 : _x.servers)) {
            for (const serv of (_y = this.swaggerConfig) === null || _y === void 0 ? void 0 : _y.servers) {
                this.documentBuilder.addServer(serv === null || serv === void 0 ? void 0 : serv.url, serv === null || serv === void 0 ? void 0 : serv.description, serv === null || serv === void 0 ? void 0 : serv.variables);
            }
        }
        if (((_z = this.swaggerConfig) === null || _z === void 0 ? void 0 : _z.tags) && Array.isArray((_0 = this.swaggerConfig) === null || _0 === void 0 ? void 0 : _0.tags)) {
            for (const t of (_2 = this.swaggerConfig) === null || _2 === void 0 ? void 0 : _2.tags) {
                this.documentBuilder.addTag(t.name, t.description, t.externalDocs);
            }
        }
        if ((_4 = (_3 = this.swaggerConfig) === null || _3 === void 0 ? void 0 : _3.documentOptions) === null || _4 === void 0 ? void 0 : _4.operationIdFactory) {
            this.operationIdFactory =
                this.swaggerConfig.documentOptions.operationIdFactory;
        }
        // 设置 auth 类型
        if (Array.isArray((_5 = this.swaggerConfig) === null || _5 === void 0 ? void 0 : _5.auth)) {
            for (const a of (_6 = this.swaggerConfig) === null || _6 === void 0 ? void 0 : _6.auth) {
                this.setAuth(a);
            }
        }
        else {
            this.setAuth((_7 = this.swaggerConfig) === null || _7 === void 0 ? void 0 : _7.auth);
        }
    }
    addGlobalPrefix(globalPrefix) {
        if (!globalPrefix) {
            return;
        }
        const paths = this.documentBuilder.getPaths();
        // 添加统一前缀后的接口地址
        const newPaths = {};
        for (const [routerUrl, value] of Object.entries(paths)) {
            // 处理路由
            if (!/^\//.test(routerUrl)) {
                newPaths[`${globalPrefix}/${routerUrl}`] = value;
            }
            else {
                newPaths[`${globalPrefix}${routerUrl}`] = value;
            }
        }
        this.documentBuilder.setPaths(newPaths);
    }
    scanApp() {
        var _a;
        const routes = (0, core_1.listModule)(core_1.CONTROLLER_KEY);
        for (const route of routes) {
            this.generatePath(route);
        }
        if ((_a = this.swaggerConfig) === null || _a === void 0 ? void 0 : _a.tagSortable) {
            this.documentBuilder.sortTags();
        }
    }
    getData() {
        return this.documentBuilder.build();
    }
    getDocumentBuilder() {
        return this.documentBuilder;
    }
    generatePath(target) {
        var _a;
        // 获取控制器元数据
        const excludeClassMeta = (0, core_1.getClassMetadata)(constants_1.DECORATORS.API_EXCLUDE_CONTROLLER, target);
        if (excludeClassMeta && excludeClassMeta.disable) {
            // 如果存在需要排除的控制器，则直接返回
            return;
        }
        const isGenerateTagForController = (_a = this.swaggerConfig.isGenerateTagForController) !== null && _a !== void 0 ? _a : true;
        // 解析额外的模型
        this.parseExtraModel(target);
        const metaForClass = (0, core_1.getClassMetadata)(constants_1.DECORATORS_CLASS_METADATA, target) || [];
        // 获取参数的元数据
        const metaForParams = (0, core_1.getClassMetadata)(core_1.INJECT_CUSTOM_PARAM, target) || [];
        // 获取控制器选项
        const controllerOption = (0, core_1.getClassMetadata)(core_1.CONTROLLER_KEY, target);
        // 获取前缀
        const prefix = controllerOption.prefix;
        // 过滤出标签
        const tags = metaForClass.filter(item => item.key === constants_1.DECORATORS.API_TAGS);
        let strTags = [];
        const controllerTags = [];
        // 如果存在标签，则将其添加到文档构建器中
        if (tags.length > 0) {
            strTags = parseTags(tags);
            strTags.forEach(tag => {
                addTag(tag, controllerTags);
            });
        }
        else {
            if (isGenerateTagForController) {
                // 如果不存在标签，则根据控制器选项生成标签
                const tag = { name: '', description: '' };
                if (prefix !== '/') {
                    tag.name =
                        (controllerOption === null || controllerOption === void 0 ? void 0 : controllerOption.routerOptions.tagName) ||
                            (/^\//.test(prefix) ? prefix.split('/')[1] : prefix);
                    tag.description =
                        (controllerOption === null || controllerOption === void 0 ? void 0 : controllerOption.routerOptions.description) || tag.name;
                }
                else {
                    tag.name = controllerOption === null || controllerOption === void 0 ? void 0 : controllerOption.routerOptions.tagName;
                    tag.description =
                        (controllerOption === null || controllerOption === void 0 ? void 0 : controllerOption.routerOptions.description) || tag.name;
                }
                // 如果标签名存在，则将其添加到文档构建器中
                if (tag.name) {
                    strTags.push(tag.name);
                    addTag([tag.name, tag.description], controllerTags);
                }
            }
            else {
                // 否则不添加标签
            }
        }
        // 获取路由信息
        const webRouterInfo = (0, core_1.getClassMetadata)(core_1.WEB_ROUTER_KEY, target);
        // 过滤出头部信息
        let headers = metaForClass.filter(item => item.key === constants_1.DECORATORS.API_HEADERS);
        if (headers.length > 0) {
            headers = headers.map(item => item.metadata);
        }
        // 过滤出安全信息（方法优先）
        const classSecurity = metaForClass.filter(item => item.key === constants_1.DECORATORS.API_SECURITY);
        // 初始化路径对象
        const paths = {};
        // 如果存在路由信息，则遍历生成路径
        if (webRouterInfo && typeof webRouterInfo[Symbol.iterator] === 'function') {
            for (const webRouter of webRouterInfo) {
                // 生成URL
                let url = (prefix + webRouter.path).replace('//', '/');
                url = replaceUrl(url, parseParamsInPath(url));
                // 方法元数据
                const metaForMethods = (0, core_1.getPropertyDataFromClass)(constants_1.DECORATORS_METHOD_METADATA, target, webRouter.method) || [];
                const methodSecurity = metaForMethods.filter(item => item.key === constants_1.DECORATORS.API_SECURITY);
                // 判断是否忽略当前路由
                const endpoints = metaForMethods.filter(item => item.key === constants_1.DECORATORS.API_EXCLUDE_ENDPOINT &&
                    item.propertyName === webRouter.method);
                // 如果存在需要忽略的路由，则跳过当前循环
                if (endpoints[0]) {
                    continue;
                }
                // 判断是否需要过滤当前路由
                if (this.swaggerConfig.routerFilter) {
                    const isFilter = this.swaggerConfig.routerFilter(url, webRouter);
                    if (isFilter) {
                        continue;
                    }
                }
                // 获取路由参数
                const routerArgs = metaForParams[webRouter.method] || [];
                // 过滤出主体参数
                const bds = routerArgs.filter(item => {
                    var _a;
                    return item.key === core_1.WEB_ROUTER_PARAM_KEY &&
                        ((_a = item === null || item === void 0 ? void 0 : item.metadata) === null || _a === void 0 ? void 0 : _a.type) === core_1.RouteParamTypes.BODY;
                });
                // 如果存在多个主体参数，则跳过当前循环，因为swagger不支持多个@Body
                if (bds.length > 1) {
                    continue;
                }
                // 生成路由方法
                this.generateRouteMethod(url, webRouter, paths, metaForMethods, routerArgs, headers, target);
                // 如果当前路径的标签长度为0，则赋值标签
                if (paths[url][webRouter.requestMethod].tags.length === 0) {
                    paths[url][webRouter.requestMethod].tags = strTags;
                }
                else {
                    // 如果 tags 不在全局中，则添加
                    paths[url][webRouter.requestMethod].tags.forEach(tag => {
                        addTag(tag, controllerTags);
                    });
                }
                // 过滤出扩展信息
                const exts = metaForMethods.filter(item => item.key === constants_1.DECORATORS.API_EXTENSION &&
                    item.propertyName === webRouter.method);
                // 如果存在扩展信息，则将其添加到路径中
                for (const e of exts) {
                    if (e.metadata) {
                        Object.assign(paths[url][webRouter.requestMethod], e.metadata);
                    }
                }
                // 优先级处理：method exclude > method security > class exclude > class security
                const hasMethodExclude = metaForMethods.find(item => item.key === constants_1.DECORATORS.API_EXCLUDE_SECURITY);
                const hasMethodSecurity = methodSecurity.length > 0;
                const hasClassExclude = metaForClass.find(item => item.key === constants_1.DECORATORS.API_EXCLUDE_SECURITY);
                const hasClassSecurity = classSecurity.length > 0;
                if (hasMethodExclude) {
                    paths[url][webRouter.requestMethod].security = [];
                }
                else if (hasMethodSecurity) {
                    paths[url][webRouter.requestMethod].security = methodSecurity
                        .map(s => s.metadata)
                        .filter(Boolean);
                }
                else if (hasClassExclude) {
                    paths[url][webRouter.requestMethod].security = [];
                }
                else if (hasClassSecurity) {
                    paths[url][webRouter.requestMethod].security = classSecurity
                        .map(s => s.metadata)
                        .filter(Boolean);
                }
            }
        }
        // 将路径添加到文档构建器中
        this.documentBuilder.addPaths(paths);
        // 将控制器标签添加到文档构建器中
        if (Object.keys(paths).length > 0) {
            controllerTags.forEach(tag => {
                if (Array.isArray(tag)) {
                    this.documentBuilder.addTag(tag[0], tag[1]);
                }
                else {
                    this.documentBuilder.addTag(tag);
                }
            });
        }
    }
    /**
     * 构造 router 提取方法
     */
    generateRouteMethod(url, webRouter, paths, metaForMethods, routerArgs, headers, target) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
        const operMeta = metaForMethods.filter(item => item.key === constants_1.DECORATORS.API_OPERATION &&
            item.propertyName === webRouter.method)[0];
        const routerTagsMeta = metaForMethods.filter(item => item.key === constants_1.DECORATORS.API_TAGS &&
            item.propertyName === webRouter.method);
        const routerTags = parseTags(routerTagsMeta);
        let opts = paths[url];
        if (!opts) {
            opts = {};
        }
        const parameters = [];
        opts[webRouter.requestMethod] = {
            summary: getNotEmptyValue((_a = operMeta === null || operMeta === void 0 ? void 0 : operMeta.metadata) === null || _a === void 0 ? void 0 : _a.summary, webRouter.summary),
            description: getNotEmptyValue((_b = operMeta === null || operMeta === void 0 ? void 0 : operMeta.metadata) === null || _b === void 0 ? void 0 : _b.description, webRouter.description),
            operationId: ((_c = operMeta === null || operMeta === void 0 ? void 0 : operMeta.metadata) === null || _c === void 0 ? void 0 : _c.operationId) ||
                this.getOperationId(target.name, webRouter),
            tags: routerTags.length ? routerTags : (_e = (_d = operMeta === null || operMeta === void 0 ? void 0 : operMeta.metadata) === null || _d === void 0 ? void 0 : _d.tags) !== null && _e !== void 0 ? _e : [],
        };
        if (((_f = operMeta === null || operMeta === void 0 ? void 0 : operMeta.metadata) === null || _f === void 0 ? void 0 : _f.deprecated) != null) {
            opts[webRouter.requestMethod].deprecated =
                !!((_g = operMeta === null || operMeta === void 0 ? void 0 : operMeta.metadata) === null || _g === void 0 ? void 0 : _g.deprecated);
        }
        /**
         * [{"key":"web:router_param","parameterIndex":1,"propertyName":"create","metadata":{"type":2}},
         * {"key":"web:router_param","parameterIndex":0,"propertyName":"create","metadata":{"type":1,"propertyData":"createCatDto"}}]
         */
        // WEB_ROUTER_PARAM_KEY
        const args = routerArgs.filter(item => {
            var _a;
            return item.key === core_1.WEB_ROUTER_PARAM_KEY &&
                ((_a = item === null || item === void 0 ? void 0 : item.metadata) === null || _a === void 0 ? void 0 : _a.type) !== core_1.RouteParamTypes.CUSTOM;
        });
        const types = (0, core_1.getMethodParamTypes)(target, webRouter.method);
        const params = metaForMethods.filter(item => item.key === constants_1.DECORATORS.API_PARAMETERS &&
            item.propertyName === webRouter.method);
        // set params information from @ApiQuery() to parameters
        for (const param of params) {
            // rebuild query param to swagger format
            if (param.metadata.schema === undefined) {
                param.metadata.schema = {};
                if (param.metadata.type) {
                    param.metadata.schema['type'] = param.metadata.type;
                    delete param.metadata.type;
                }
                if (param.metadata.isArray) {
                    param.metadata.schema['items'] = {
                        type: param.metadata.schema['type'],
                    };
                    param.metadata.schema['type'] = 'array';
                    delete param.metadata.isArray;
                }
                if (param.metadata.enum !== undefined) {
                    param.metadata.schema.enum = param.metadata.enum;
                    delete param.metadata.enum;
                }
            }
            else {
                // if schema is defined, then type is not needed
                delete param.metadata.type;
                delete param.metadata.isArray;
                delete param.metadata.enum;
            }
            const p = param.metadata;
            p.schema = this.formatType(param.metadata.schema);
            if (p.in === 'query' || p.in === 'path' || p.in === 'header') {
                parameters.push(p);
            }
            else if (p.in === 'body') {
                p.content = (_h = p.content) !== null && _h !== void 0 ? _h : {};
                if (Object.keys(p.content).length === 0) {
                    p.content[p.contentType || 'application/json'] = (_j = p.content[p.contentType || 'application/json']) !== null && _j !== void 0 ? _j : {
                        schema: p.schema,
                    };
                }
                // format schema
                for (const key in p.content) {
                    p.content[key].schema = this.formatType(p.content[key].schema);
                }
                // if requestBody is already set, skip
                opts[webRouter.requestMethod].requestBody =
                    (_k = opts[webRouter.requestMethod].requestBody) !== null && _k !== void 0 ? _k : {};
                opts[webRouter.requestMethod].requestBody.description =
                    (_l = opts[webRouter.requestMethod].requestBody.description) !== null && _l !== void 0 ? _l : p.description;
                opts[webRouter.requestMethod].requestBody.content =
                    (_m = opts[webRouter.requestMethod].requestBody.content) !== null && _m !== void 0 ? _m : p.content;
                opts[webRouter.requestMethod].requestBody.required =
                    (_o = opts[webRouter.requestMethod].requestBody.required) !== null && _o !== void 0 ? _o : p.required;
            }
        }
        for (const arg of args) {
            const currentType = types[arg.parameterIndex];
            const p = {
                name: (_p = arg === null || arg === void 0 ? void 0 : arg.metadata) === null || _p === void 0 ? void 0 : _p.propertyData,
                in: convertTypeToString((_q = arg.metadata) === null || _q === void 0 ? void 0 : _q.type),
                required: false,
            };
            const existsParam = parameters.find(item => {
                var _a;
                return item.name === ((_a = arg === null || arg === void 0 ? void 0 : arg.metadata) === null || _a === void 0 ? void 0 : _a.propertyData) && item.in === p.in;
            });
            // if exists same param from @ApiQuery and other decorator, just skip
            if (existsParam) {
                continue;
            }
            if (p.in === 'path') {
                p.required = true;
                if (url.indexOf('{' + p.name + '}') === -1) {
                    continue;
                }
            }
            if (core_1.Types.isClass(currentType)) {
                this.parseClzz(currentType);
            }
            if (p.in === 'query' || p.in === 'path') {
                if (core_1.Types.isClass(currentType)) {
                    // 如果@Query()装饰的 是一个对象，则把该对象的子属性作为多个@Query参数
                    const schema = this.documentBuilder.getSchema(currentType.name);
                    Object.keys(schema.properties).forEach(pName => {
                        var _a, _b;
                        const pp = {
                            name: pName,
                            in: p.in,
                            description: (_a = schema.properties[pName]) === null || _a === void 0 ? void 0 : _a.description,
                            schema: schema.properties[pName],
                            required: ((_b = schema.required) === null || _b === void 0 ? void 0 : _b.includes(pName)) || false,
                        };
                        parameters.push(pp);
                    });
                    continue;
                }
                else {
                    if (!p.name) {
                        continue;
                    }
                    p.schema = {
                        type: convertSchemaType((_r = currentType === null || currentType === void 0 ? void 0 : currentType.name) !== null && _r !== void 0 ? _r : currentType),
                    };
                }
            }
            else if (p.in === 'body') {
                if (webRouter.requestMethod === core_1.RequestMethod.GET) {
                    continue;
                }
                // if requestBody is already set, skip
                if (opts[webRouter.requestMethod].requestBody) {
                    continue;
                }
                // 这里兼容一下 @File()、@Files()、@Fields() 装饰器
                if (((_s = arg.metadata) === null || _s === void 0 ? void 0 : _s.type) === core_1.RouteParamTypes.FILESSTREAM) {
                    p.content = {};
                    p.content[_1.BodyContentType.Multipart] = {
                        schema: {
                            type: 'object',
                            properties: {
                                files: {
                                    type: 'array',
                                    items: {
                                        type: 'string',
                                        format: 'binary',
                                    },
                                    description: p.description,
                                },
                            },
                        },
                    };
                }
                else if (((_t = arg.metadata) === null || _t === void 0 ? void 0 : _t.type) === core_1.RouteParamTypes.FILESTREAM) {
                    p.content = {};
                    p.content[_1.BodyContentType.Multipart] = {
                        schema: {
                            type: 'object',
                            properties: {
                                file: {
                                    type: 'string',
                                    format: 'binary',
                                    description: p.description,
                                },
                            },
                        },
                    };
                }
                else {
                    if (core_1.Types.isClass(currentType)) {
                        p.content = {
                            'application/json': {
                                schema: {
                                    $ref: '#/components/schemas/' + currentType.name,
                                },
                            },
                        };
                    }
                    else {
                        // base type
                        p.content = {
                            'text/plain': {
                                schema: {
                                    type: convertSchemaType((_u = currentType === null || currentType === void 0 ? void 0 : currentType.name) !== null && _u !== void 0 ? _u : currentType),
                                },
                            },
                        };
                    }
                }
                opts[webRouter.requestMethod].requestBody = {
                    required: true,
                    description: p.description || p.name,
                    content: p.content,
                };
                // in body 不需要处理
                continue;
            }
            parameters.push(p);
        }
        // class header 需要使用 ApiHeader 装饰器
        if (headers && headers.length) {
            headers.forEach(header => parameters.unshift(header));
        }
        // 获取方法上的 @ApiHeader
        const methodHeaders = metaForMethods.filter(item => item.key === constants_1.DECORATORS.API_HEADERS);
        if (methodHeaders.length > 0) {
            methodHeaders.forEach(item => parameters.unshift(item.metadata));
        }
        opts[webRouter.requestMethod].parameters = parameters;
        const responses = metaForMethods.filter(item => item.key === constants_1.DECORATORS.API_RESPONSE &&
            item.propertyName === webRouter.method);
        const returnResponses = {};
        for (const r of responses) {
            const resp = r.metadata;
            const keys = Object.keys(resp);
            for (const k of keys) {
                // 这里是引用，赋值可以直接更改
                const tt = resp[k];
                if (tt.schema) {
                    // response 的 schema 需要包含在 content 内
                    tt.content = {
                        'application/json': {
                            schema: this.formatType(tt.schema),
                        },
                    };
                    delete tt.schema;
                }
                else if (tt.type) {
                    if (core_1.Types.isClass(tt.type)) {
                        this.parseClzz(tt.type);
                        if (tt.isArray) {
                            tt.content = {
                                'application/json': {
                                    schema: {
                                        type: 'array',
                                        items: {
                                            $ref: '#/components/schemas/' + tt.type.name,
                                        },
                                    },
                                },
                            };
                        }
                        else {
                            tt.content = {
                                'application/json': {
                                    schema: {
                                        $ref: '#/components/schemas/' + tt.type.name,
                                    },
                                },
                            };
                        }
                    }
                    else {
                        tt.content = {
                            'text/plain': {
                                schema: {
                                    type: convertSchemaType(tt.type),
                                },
                            },
                        };
                    }
                }
                delete tt.status;
                delete tt.type;
                delete tt.isArray;
                delete tt.format;
            }
            Object.assign(returnResponses, resp);
        }
        if (Object.keys(returnResponses).length > 0) {
            opts[webRouter.requestMethod].responses = returnResponses;
        }
        else {
            opts[webRouter.requestMethod].responses = {
                200: {
                    description: 'OK',
                },
            };
        }
        paths[url] = opts;
    }
    getOperationId(controllerKey, webRouter) {
        return this.operationIdFactory(controllerKey, webRouter);
    }
    /**
     * 解析 ApiExtraModel
     * @param clzz
     */
    parseExtraModel(clzz) {
        const metaForClass = (0, core_1.getClassMetadata)(constants_1.DECORATORS_CLASS_METADATA, clzz) || [];
        const extraModels = metaForClass.filter(item => item.key === constants_1.DECORATORS.API_EXTRA_MODEL);
        for (const m of extraModels) {
            if (Array.isArray(m.metadata)) {
                for (const sclz of m.metadata) {
                    this.parseClzz(sclz);
                }
            }
            else {
                this.parseClzz(m.metadata);
            }
        }
    }
    parseSubPropertyType(metadata) {
        var _a, _b, _c;
        let typeMeta;
        if (metadata === null || metadata === void 0 ? void 0 : metadata.enum) {
            typeMeta = {
                type: metadata === null || metadata === void 0 ? void 0 : metadata.type,
                enum: metadata === null || metadata === void 0 ? void 0 : metadata.enum,
                default: metadata === null || metadata === void 0 ? void 0 : metadata.default,
            };
            if (metadata === null || metadata === void 0 ? void 0 : metadata.description) {
                typeMeta.description = metadata === null || metadata === void 0 ? void 0 : metadata.description;
            }
            return typeMeta;
        }
        if ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.items) === null || _a === void 0 ? void 0 : _a.enum) {
            typeMeta = {
                type: metadata === null || metadata === void 0 ? void 0 : metadata.type,
                items: metadata === null || metadata === void 0 ? void 0 : metadata.items,
                default: metadata === null || metadata === void 0 ? void 0 : metadata.default,
            };
            if (metadata === null || metadata === void 0 ? void 0 : metadata.description) {
                typeMeta.description = metadata === null || metadata === void 0 ? void 0 : metadata.description;
            }
            return typeMeta;
        }
        let isArray = false;
        let currentType = parseTypeSchema(metadata === null || metadata === void 0 ? void 0 : metadata.type);
        metadata === null || metadata === void 0 ? true : delete metadata.type;
        if (currentType === 'array') {
            isArray = true;
            currentType = parseTypeSchema((_b = metadata === null || metadata === void 0 ? void 0 : metadata.items) === null || _b === void 0 ? void 0 : _b.type);
            metadata === null || metadata === void 0 ? true : delete metadata.items.type;
        }
        if (metadata === null || metadata === void 0 ? void 0 : metadata.oneOf) {
            typeMeta = {
                oneOf: [],
            };
            metadata === null || metadata === void 0 ? void 0 : metadata.oneOf.forEach((item) => {
                typeMeta.push(this.parseSubPropertyType(item));
            });
            metadata === null || metadata === void 0 ? true : delete metadata.oneOf;
        }
        if (core_1.Types.isClass(currentType)) {
            this.parseClzz(currentType);
            if (isArray) {
                typeMeta = {
                    type: 'array',
                    items: {
                        $ref: '#/components/schemas/' + (currentType === null || currentType === void 0 ? void 0 : currentType.name),
                    },
                };
            }
            else {
                typeMeta = {
                    $ref: '#/components/schemas/' + (currentType === null || currentType === void 0 ? void 0 : currentType.name),
                };
            }
            delete metadata.items;
        }
        else {
            if (isArray) {
                // 没有配置类型则认为自己配置了 items 内容
                if (!currentType) {
                    if ((_c = metadata === null || metadata === void 0 ? void 0 : metadata.items) === null || _c === void 0 ? void 0 : _c['$ref']) {
                        metadata.items['$ref'] = parseTypeSchema(metadata.items['$ref']);
                    }
                    typeMeta = {
                        type: 'array',
                        items: metadata === null || metadata === void 0 ? void 0 : metadata.items,
                    };
                }
                else {
                    typeMeta = {
                        type: 'array',
                        items: {
                            type: convertSchemaType((currentType === null || currentType === void 0 ? void 0 : currentType.name) || currentType),
                        },
                    };
                }
                delete metadata.items;
            }
            else {
                typeMeta = {
                    type: currentType,
                    format: metadata === null || metadata === void 0 ? void 0 : metadata.format,
                };
                // Date 类型支持
                if (typeMeta.type === 'Date') {
                    typeMeta.type = 'string';
                    if (!typeMeta.format) {
                        typeMeta.format = 'date';
                    }
                }
                delete metadata.format;
            }
        }
        return Object.assign(typeMeta, metadata);
    }
    formatType(metadata) {
        if (metadata === null) {
            return null;
        }
        // 如果有枚举，单独处理
        if (metadata.enum) {
            if (Array.isArray(metadata.enum)) {
                // enum 不需要处理
                metadata.enum.map(item => this.formatType(item));
            }
            else {
                // 枚举类型需要处理
                metadata.enum = (0, enum_utils_1.getEnumValues)(metadata.enum);
            }
        }
        if (metadata.not) {
            metadata.not = this.formatType(metadata.not);
        }
        if (metadata['$ref'] && typeof metadata['$ref'] === 'function') {
            metadata['$ref'] = metadata['$ref']();
        }
        if (metadata.oneOf) {
            metadata.oneOf = metadata.oneOf.map(item => this.formatType(item));
        }
        else if (metadata.anyOf) {
            metadata.anyOf = metadata.anyOf.map(item => this.formatType(item));
        }
        else if (metadata.allOf) {
            metadata.allOf = metadata.allOf.map(item => this.formatType(item));
        }
        // 有下面的这些属性，就不需要 type 了
        ['not', '$ref', 'oneOf', 'anyOf', 'allOf'].forEach(key => {
            if (metadata[key]) {
                delete metadata['type'];
            }
        });
        if (metadata.properties) {
            const properties = {};
            for (const key in metadata.properties) {
                properties[key] = this.formatType(metadata.properties[key]);
            }
            metadata.properties = properties;
        }
        if (metadata.additionalProperties) {
            metadata.additionalProperties = this.formatType(metadata.additionalProperties);
        }
        // 处理类型
        if (['string', 'number', 'boolean', 'integer'].includes(metadata.type)) {
            // 不做处理
        }
        else if (metadata.type === Number) {
            metadata.type = 'number';
        }
        else if (metadata.type === String) {
            metadata.type = 'string';
        }
        else if (metadata.type === Boolean) {
            metadata.type = 'boolean';
        }
        else if (metadata.type === 'date' ||
            metadata.type === 'Date' ||
            metadata.type === Date) {
            metadata.type = 'string';
            metadata.format = 'date-time';
        }
        else if (metadata.type === Array || metadata.type === 'array') {
            // Array => { type: 'array' }
            metadata.type = 'array';
            if (metadata.items) {
                metadata.items = this.formatType(metadata.items);
            }
        }
        else if (Array.isArray(metadata.type)) {
            // [String] => { type: 'array', items: { type: 'string' } }
            metadata.items = this.formatType({ type: metadata.type[0] });
            metadata.type = 'array';
        }
        else if (metadata.type === Object || metadata.type === 'object') {
            metadata.type = 'object';
        }
        else if (core_1.Types.isClass(metadata.type)) {
            this.parseClzz(metadata.type);
            metadata['$ref'] = '#/components/schemas/' + metadata.type.name;
            delete metadata['type'];
        }
        else if (metadata.type instanceof Function) {
            // () => String => { type: 'string' }
            metadata.type = metadata.type();
            this.formatType(metadata);
        }
        return metadata;
    }
    /**
     * 解析类型的 ApiProperty
     * @param clzz
     */
    parseClzz(clzz) {
        if (this.documentBuilder.getSchema(clzz.name)) {
            return this.documentBuilder.getSchema(clzz.name);
        }
        // 解析 ApiExtraModel
        this.parseExtraModel(clzz);
        // 解析类上的 ApiProperty
        // TODO 这里后面不能用这个方法
        const props = (0, core_1.getClassExtendedMetadata)(core_1.INJECT_CUSTOM_PROPERTY, clzz);
        const tt = {
            type: 'object',
            properties: {},
        };
        // 先添加到 schema，防止递归循环
        this.documentBuilder.addSchema({
            [clzz.name]: tt,
        });
        if (props) {
            for (const key of Object.keys(props)) {
                const metadata = props[key].metadata || {};
                if (!metadata.type) {
                    // 推导类型
                    metadata.type = (0, core_1.getPropertyType)(clzz.prototype, key).name;
                }
                tt.properties[key] = tt.properties[key] || {};
                // loop metadata
                for (const metadataKey in metadata) {
                    if (metadataKey === 'required' && metadata['required']) {
                        // required 需要加到 schema 上
                        if (!tt.required) {
                            tt.required = [];
                        }
                        tt.required.push(key);
                    }
                    else if (['oneOf', 'anyOf', 'allOf'].includes(metadataKey)) {
                        tt.properties[key][metadataKey] = [];
                        metadata[metadataKey].forEach((meta) => {
                            tt.properties[key][metadataKey].push(this.formatType(meta));
                        });
                    }
                    else if (metadataKey === 'not') {
                        tt.properties[key][metadataKey] = this.formatType(metadata[metadataKey]);
                    }
                    else if (metadataKey === 'type') {
                        this.formatType(metadata);
                        if (metadata.type) {
                            tt.properties[key].type = metadata.type;
                        }
                        if (metadata['$ref']) {
                            tt.properties[key].$ref = metadata['$ref'];
                        }
                        if (metadata.items) {
                            tt.properties[key].items = metadata.items;
                        }
                        if (metadata.format) {
                            tt.properties[key].format = metadata.format;
                        }
                        if (metadata.pattern) {
                            tt.properties[key].pattern = metadata.pattern;
                        }
                        if (metadata.enum) {
                            tt.properties[key].enum = metadata.enum;
                        }
                    }
                    else if (metadataKey === 'items' ||
                        metadataKey === 'pattern' ||
                        metadataKey === 'format' ||
                        metadataKey === 'enum' ||
                        metadataKey === '$ref') {
                        // type 中已经处理
                    }
                    else {
                        tt.properties[key][metadataKey] = metadata[metadataKey];
                    }
                }
            }
        }
        // just for test
        return tt;
    }
    /**
     * 授权验证
     * @param opts
     * @returns
     */
    setAuth(opts) {
        if (!opts) {
            return;
        }
        const { authType, name = '', addSecurityRequirements = false, ...otherOptions } = opts;
        if (!authType) {
            return;
        }
        switch (authType) {
            case 'basic': {
                this.documentBuilder.addBasicAuth(otherOptions, name);
                break;
            }
            case 'bearer': {
                this.documentBuilder.addBearerAuth(otherOptions, name);
                break;
            }
            case 'cookie': {
                const { cookieName, securityName, ...options } = otherOptions;
                this.documentBuilder.addCookieAuth(cookieName, options, securityName);
                break;
            }
            case 'oauth2': {
                this.documentBuilder.addOAuth2(otherOptions, name);
                break;
            }
            case 'apikey': {
                this.documentBuilder.addApiKey(otherOptions, name);
                break;
            }
            case 'custom': {
                this.documentBuilder.addSecurity(name, otherOptions);
                break;
            }
        }
        if (addSecurityRequirements) {
            // 添加安全要求
            this.documentBuilder.addSecurityRequirements(name);
        }
    }
};
__decorate([
    (0, core_1.Config)('swagger'),
    __metadata("design:type", Object)
], SwaggerExplorer.prototype, "swaggerConfig", void 0);
__decorate([
    (0, core_1.Init)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], SwaggerExplorer.prototype, "init", null);
SwaggerExplorer = __decorate([
    (0, core_1.Provide)(),
    (0, core_1.Scope)(core_1.ScopeEnum.Singleton)
], SwaggerExplorer);
exports.SwaggerExplorer = SwaggerExplorer;
/**
 * 解释路由上的参数
 * @param url
 */
function parseParamsInPath(url) {
    const names = [];
    url.split('/').forEach(item => {
        if (item.startsWith(':')) {
            const paramName = item.slice(1);
            names.push(paramName);
        }
    });
    return names;
}
/**
 * 替换成 openapi 的url
 * @param url
 * @param names
 */
function replaceUrl(url, names) {
    names.forEach(n => {
        url = url.replace(`:${n}`, `{${n}}`);
    });
    return url;
}
function convertTypeToString(type) {
    switch (type) {
        case core_1.RouteParamTypes.HEADERS:
            return 'header';
        case core_1.RouteParamTypes.QUERY:
            return 'query';
        case core_1.RouteParamTypes.PARAM:
            return 'path';
        case core_1.RouteParamTypes.BODY:
        case core_1.RouteParamTypes.FIELDS:
        case core_1.RouteParamTypes.FILESSTREAM:
        case core_1.RouteParamTypes.FILESTREAM:
            return 'body';
        default:
            return 'header';
    }
}
function convertSchemaType(value) {
    switch (value) {
        case 'Object':
            return 'object';
        case 'Boolean':
            return 'boolean';
        case 'Number':
            return 'number';
        case 'String':
            return 'string';
        default:
            return 'object';
    }
}
function getNotEmptyValue(...args) {
    for (const arg of args) {
        if (arg) {
            return arg;
        }
    }
}
function parseTypeSchema(ref) {
    switch (ref) {
        case String:
            return 'string';
        case Number:
            return 'number';
        case Boolean:
            return 'boolean';
        default:
            if (typeof ref === 'function' && !core_1.Types.isClass(ref)) {
                ref = ref();
            }
            return ref;
    }
}
function parseTags(tags) {
    let strTags = [];
    if (tags.length > 0) {
        for (const t of tags) {
            // 这里 metadata => string[]
            strTags = strTags.concat(t.metadata);
        }
    }
    return strTags;
}
function addTag(newTag, tags = []) {
    /**
     * tag 结构
     * ['name', 'description'] 或者 'name'
     */
    if (
    // 处理重复的标签
    tags.find(t => {
        if (Array.isArray(newTag)) {
            return t === newTag[0];
        }
        else {
            return t === newTag;
        }
    })) {
        // ignore
    }
    else {
        tags.push(newTag);
    }
}
//# sourceMappingURL=swaggerExplorer.js.map