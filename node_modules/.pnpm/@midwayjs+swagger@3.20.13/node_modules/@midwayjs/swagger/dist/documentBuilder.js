"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentBuilder = void 0;
class DocumentBuilder {
    constructor() {
        this.document = {
            openapi: '3.0.1',
            info: {
                title: '',
                description: '',
                version: '1.0.0',
                contact: {},
            },
            tags: [],
            servers: [],
            components: {},
            paths: {},
        };
    }
    setTitle(title) {
        this.document.info.title = title;
        return this;
    }
    setDescription(description) {
        this.document.info.description = description;
        return this;
    }
    setVersion(version) {
        this.document.info.version = version;
        return this;
    }
    setTermsOfService(termsOfService) {
        this.document.info.termsOfService = termsOfService;
        return this;
    }
    setContact(name, url, email) {
        this.document.info.contact = { name, url, email };
        return this;
    }
    setLicense(name, url) {
        this.document.info.license = { name, url };
        return this;
    }
    addServer(url, description, variables) {
        this.document.servers.push({ url, description, variables });
        return this;
    }
    setExternalDoc(description, url) {
        this.document.externalDocs = { description, url };
        return this;
    }
    addPaths(paths) {
        Object.assign(this.document.paths, paths);
        return this;
    }
    getPaths() {
        return this.document.paths;
    }
    setPaths(paths) {
        this.document.paths = paths;
        return this;
    }
    addSchema(schema) {
        if (!this.document.components.schemas) {
            this.document.components.schemas = {};
        }
        Object.assign(this.document.components.schemas, schema);
        return this;
    }
    getSchema(name) {
        var _a, _b;
        if ((_a = this.document.components) === null || _a === void 0 ? void 0 : _a.schemas) {
            return (_b = this.document.components) === null || _b === void 0 ? void 0 : _b.schemas[name];
        }
        return undefined;
    }
    addTag(name, description = '', externalDocs) {
        const tags = this.document.tags || [];
        if (Array.isArray(name)) {
            const arr = name;
            for (const s of arr) {
                if (!tags.find(tag => tag.name === name)) {
                    tags.push({
                        name: s,
                        description: '',
                    });
                }
            }
            return this;
        }
        if (!tags.find(tag => tag.name === name)) {
            tags.push({
                name,
                description,
                externalDocs,
            });
        }
        else {
            // update description and externalDocs
            tags.forEach(tag => {
                if (tag.name === name) {
                    if (description) {
                        tag.description = description;
                    }
                    if (externalDocs) {
                        tag.externalDocs = externalDocs;
                    }
                }
            });
        }
        this.document.tags = tags;
        return this;
    }
    addSecurity(name, options) {
        this.document.components.securitySchemes = {
            ...(this.document.components.securitySchemes || {}),
            [name]: options,
        };
        return this;
    }
    addSecurityRequirements(name, requirements = []) {
        let securityRequirement;
        if (typeof name === 'string') {
            securityRequirement = { [name]: requirements };
        }
        else {
            securityRequirement = name;
        }
        this.document.security = (this.document.security || []).concat({
            ...securityRequirement,
        });
        return this;
    }
    addBearerAuth(options = {
        type: 'http',
    }, name = 'bearer') {
        this.addSecurity(name, {
            type: 'http',
            scheme: 'bearer',
            bearerFormat: 'JWT',
            ...options,
        });
        return this;
    }
    addOAuth2(options = {
        type: 'oauth2',
    }, name = 'oauth2') {
        if (!name) {
            name = 'oauth2';
        }
        this.addSecurity(name, {
            type: 'oauth2',
            flows: {
                ...options === null || options === void 0 ? void 0 : options.flows,
            },
        });
        return this;
    }
    addApiKey(options = {
        type: 'apiKey',
    }, name = 'api_key') {
        if (!name) {
            name = 'api_key';
        }
        this.addSecurity(name, {
            type: 'apiKey',
            in: 'header',
            name,
            ...options,
        });
        return this;
    }
    addBasicAuth(options = {
        type: 'http',
    }, name = 'basic') {
        if (!name) {
            name = 'basic';
        }
        this.addSecurity(name, {
            type: 'http',
            scheme: 'basic',
            ...options,
        });
        return this;
    }
    addCookieAuth(cookieName = 'connect.sid', options = {
        type: 'apiKey',
    }, securityName = 'cookie') {
        if (!cookieName) {
            cookieName = 'connect.sid';
        }
        if (!securityName) {
            securityName = 'cookie';
        }
        this.addSecurity(securityName, {
            type: 'apiKey',
            in: 'cookie',
            name: cookieName,
            ...options,
        });
        return this;
    }
    sortTags() {
        const tags = this.document.tags;
        this.document.tags = tags.sort((a, b) => {
            const s1 = a.name;
            const s2 = b.name;
            const len = s1.length > s2.length ? s2.length : s1.length;
            for (let i = 0; i < len; i++) {
                if (s1.charCodeAt(i) > s2.charCodeAt(i)) {
                    return 1;
                }
                else if (s1.charCodeAt(i) < s2.charCodeAt(i)) {
                    return -1;
                }
            }
            return 0;
        });
    }
    build() {
        return this.document;
    }
}
exports.DocumentBuilder = DocumentBuilder;
//# sourceMappingURL=documentBuilder.js.map